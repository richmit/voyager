# -*- Mode:Org; Coding:utf-8; fill-column:158 -*-
# ######################################################################################################################################################.H.S.##
# FILE:        readme.org
#+TITLE:       HP Voyager Programs
#+SUBTITLE:    For HP-15C
#+AUTHOR:      Mitch Richling
#+EMAIL:       http://www.mitchr.me/
#+DATE:        2024-02-03
#+DESCRIPTION: Various programs for HP Voyager series calculators
#+KEYWORDS:    Hewlett Packard RPN RPL
#+LANGUAGE:    en
#+OPTIONS:     num:t toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t skip:nil d:nil todo:t pri:nil H:5 p:t author:t html-scripts:nil
#+SEQ_TODO:    TODO:NEW(t)                         TODO:WORK(w)    TODO:HOLD(h)    | TODO:FUTURE(f)   TODO:DONE(d)    TODO:CANCELED(c)
#+PROPERTY: header-args :eval never-export
#+HTML_HEAD: <style>body { width: 95%; margin: 2% auto; font-size: 18px; line-height: 1.4em; font-family: Georgia, serif; color: black; background-color: white; }</style>
# Change max-width to get wider output -- also note #content style below
#+HTML_HEAD: <style>body { min-width: 500px; max-width: 1024px; }</style>
#+HTML_HEAD: <style>h1,h2,h3,h4,h5,h6 { color: #A5573E; line-height: 1em; font-family: Helvetica, sans-serif; }</style>
#+HTML_HEAD: <style>h1,h2,h3 { line-height: 1.4em; }</style>
#+HTML_HEAD: <style>h1.title { font-size: 3em; }</style>
#+HTML_HEAD: <style>.subtitle { font-size: 0.6em; }</style>
#+HTML_HEAD: <style>h4,h5,h6 { font-size: 1em; }</style>
#+HTML_HEAD: <style>.org-src-container { border: 1px solid #ccc; box-shadow: 3px 3px 3px #eee; font-family: Lucida Console, monospace; font-size: 80%; margin: 0px; padding: 0px 0px; position: relative; }</style>
#+HTML_HEAD: <style>.org-src-container>pre { line-height: 1.2em; padding-top: 1.5em; margin: 0.5em; background-color: #404040; color: white; overflow: auto; }</style>
#+HTML_HEAD: <style>.org-src-container>pre:before { display: block; position: absolute; background-color: #b3b3b3; top: 0; right: 0; padding: 0 0.2em 0 0.4em; border-bottom-left-radius: 8px; border: 0; color: white; font-size: 100%; font-family: Helvetica, sans-serif;}</style>
#+HTML_HEAD: <style>pre.example { white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -o-pre-wrap; font-family: Lucida Console, monospace; font-size: 80%; background: #404040; color: white; display: block; padding: 0em; border: 2px solid black; }</style>
#+HTML_HEAD: <style>blockquote { margin-bottom: 0.5em; padding: 0.5em; background-color: #FFF8DC; border-left: 2px solid #A5573E; border-left-color: rgb(255, 228, 102); display: block; margin-block-start: 1em; margin-block-end: 1em; margin-inline-start: 5em; margin-inline-end: 5em; } </style>
# Change the following to get wider output -- also note body style above
#+HTML_HEAD: <style>#content { max-width: 60em; }</style>
#+HTML_LINK_HOME: https://www.mitchr.me/
#+HTML_LINK_UP: https://richmit.github.io/voyager/
# ######################################################################################################################################################.H.E.##

#+ATTR_HTML: :border 2 solid #ccc :frame hsides :align center
|          <r> | <l>                                 |
|    *Author:* | /{{{author}}}/                      |
|   *Updated:* | /{{{modification-time(%Y-%m-%d)}}}/ |
| *Generated:* | /{{{time(%Y-%m-%d)}}}/              |
#+ATTR_HTML: :align center
Copyright \copy {{{time(%Y)}}} Mitch Richling. All rights reserved.

* Introduction
:PROPERTIES:
:CUSTOM_ID: intro
:END:

The HP-15C was designed over 40 years ago.  By modern standards it is missing many features found in scientific calculators today; however, the HP-15C is far
more efficient than modern machines.  
#+BEGIN_QUOTE
 - Fewer keystrokes ::
   Calculations that require half a dozen keystrokes on the HP-15C might take a couple dozen keystrokes on a modern
   calculator.  
 - All functionality directly available from the keyboard ::
   Not only do modern machines require more keystrokes, but many of those keystrokes are for navigating through menus.  On the HP-15C everything is no more
   than a couple keystrokes away.
 - Great keyboard ::
   The layout is designed for speed.  Mechanically it doesn't bounce or cause double entries.  It has tactical feedback to confirm key activation.  These
   features mean long time HP-15C users can stay focused on the problem at hand while touch typing problems into the machine.
#+END_QUOTE

Most of the time I preform calculations with [[https://www.mitchr.me/SS/tools/index.html#mathNstats][specialized mathematical software]].  Still each day
brings a plethora of little, ad-hoc engineering computations for which the HP-15C is simply the fastest way to hammer out an answer -- this is what keeps the
HP-15C on my desk.

- Most of the programs found here are all about efficiency: 
  - Efficient replacements for STO/RCL with complex numbers
  - Reducing the tedium of matrix computations.
- Only one is about new functionality:
  - Newton's method for functions of a complex variable

#+TOC: headlines 5

#+INCLUDE: emacs.org

* Store & Recall Complex Numbers
:PROPERTIES:
:CUSTOM_ID: storclcplx
:END:

The official user guide has a pair of example programs capable of storing and recalling complex values using a matrix for storage.  The programs here are
similar except that they use registrars for storage -- storing the real and complex parts in consecutive storage registers.

With respect to the stack, these programs attempt to behave like the built in =STO= & =RCL= functions:
 - They both preserve the stack contents
 - The =STO_CPLX= program leaves the item to be stored in the {{{stk(X)}}} stack position

If the calculator is not already in complex mode, then it will be placed in complex mode by the program.

** Usage
:PROPERTIES:
:CUSTOM_ID: storclcplxUsage
:END:

- Inputs:
 - =STO_CPLX=: The number to store is on stack level {{{stk(Y)}}}, and the first register index is on stack level {{{stk(X)}}}.  \\
               The real part of {{{stk(Y)}}} is stored at the register indicated by the index in X, and the complex part of {{{stk(Y)}}} is stored in the next consecutive register.
 - =RCL_CPLX=: The first register index is on stack level {{{stk(X)}}}.
- The result stack:
 - =STO_CPLX=: The stack is shifted down so the register index is in stack position {{{stk(T)}}}.
 - =RCL_CPLX=: The register index in stack position {{{stk(X)}}} is replaced by the recalled complex number, and the other stack levels are left unchanged.
- Error Conditions
 - Given register is out of bounds: An =Error 3= will be produced & the stack contents will be invalidated.
 - Given register plus one is out of bounds: An =Error 3= will be produced, the stack contents will be invalidated, and the value in the given register will be invalidated.

** Stack Diagrams
:PROPERTIES:
:CUSTOM_ID: storclcplxStk
:END:

#+BEGIN_CENTER
*=STO_CPLX=* -- Store Complex Number
#+END_CENTER
#+ATTR_HTML: :align center :cellpadding 3em
|      <c>      | <l>         | <l>         |
|               | *Before*    | *After*     |
| {{{stk(T)}}}: | t           | Reg Index   |
| {{{stk(Z)}}}: | z           | t           |
| {{{stk(Y)}}}: | Cplx Number | z           |
| {{{stk(X)}}}: | Reg Index   | Cplx Number |

#+BEGIN_CENTER
*=RCL_CPLX=* -- Recall Complex Number
#+END_CENTER
#+ATTR_HTML: :align center :cellpadding 3em
|      <c>      | <l>       | <l>         |
|               | *Before*  | *After*     |
| {{{stk(T)}}}: | t         | t           |
| {{{stk(Z)}}}: | z         | z           |
| {{{stk(Y)}}}: | y         | y           |
| {{{stk(X)}}}: | Reg Index | Cplx Number |

** Resources Used
:PROPERTIES:
:CUSTOM_ID: storclcplxRes
:END:

- Entry Point Labels:
  - {{{lbl( E )}}} RCL_CPLX -- =STO_CPLX= on the left and =RCL_CPLX= on the right -- just like the {{{c15(STO)}}} & {{{c15(RCL)}}} buttons
  - {{{lbl( D )}}} STO_CPLX
- Internal Labels:
  - None
- External Labels:
  - None
- Registers Used:
  - Two consecutive registers are used.
  - The first has its index on level  {{{stk(X)}}} of the stack
- Matrices:
  - None

** Program Listing
:PROPERTIES:
:CUSTOM_ID: storclcplxCode
:END:

#+BEGIN_CENTER
=STO_CPLX= -- Store Complex Number
#+END_CENTER
#+ATTR_HTML: :align center :cellpadding 1em
| <l>                    |         <r> |    <c>    |              <r> |    <c>    | <l>        |
| *Keystrokes* {{{SPC}}} | *Key Codes* | {{{SPC}}} | *Stack Contents* | {{{SPC}}} | *Comments* |
| {{{c15( f LBL D )}}}   |  =42,21,14= |           |          x y z t |           |            |
| {{{c15( STO I   )}}}   |     =44 25= |           |          x y z t |           |            |
| {{{c15( R↓      )}}}   |        =33= |           |          y z t x |           |            |
| {{{c15( STO (i) )}}}   |     =44 24= |           |          y z t x |           |            |
| {{{c15( f ISG I )}}}   |  =42, 6,25= |           |          y z t x |           |            |
| {{{c15( g CLx   )}}}   |     =43 35= |           |          y z t x |           | NOP        |
| {{{c15( f Re≷Im )}}}   |     =42 30= |           |         ~y z t x |           |            |
| {{{c15( STO (i) )}}}   |     =44 24= |           |         ~y z t x |           |            |
| {{{c15( f Re≷Im )}}}   |     =42 30= |           |          y z t x |           | Ret        |
| {{{c15( g RTN   )}}}   |     =43 32= |           |                  |           |            |
#+BEGIN_CENTER
=RCL_CPLX= -- Recall Complex Number
#+END_CENTER
#+ATTR_HTML: :align center :cellpadding 1em
| <l>                    |         <r> |    <c>    |              <r> |    <c>    | <l>           |
| *Keystrokes* {{{SPC}}} | *Key Codes* | {{{SPC}}} | *Stack Contents* | {{{SPC}}} | *Comments*    |
| {{{c15( f LBL E )}}}   |  =42,21,15= |           |          x y z t |           |               |
| {{{c15( STO I   )}}}   |     =44 25= |           |          x y z t |           |               |
| {{{c15( R↓      )}}}   |        =33= |           |          y z t x |           |               |
| {{{c15( RCL (i) )}}}   |     =45 24= |           |         Cr y z t |           |               |
| {{{c15( f ISG I )}}}   |   =42,6,25= |           |         Cr y z t |           |               |
| {{{c15( g CLx   )}}}   |     =43 35= |           |         Cr y z t |           | NOP           |
| {{{c15( f Re≷Im )}}}   |     =42 30= |           |        ~Cr y z t |           |               |
| {{{c15( g CLx   )}}}   |     =43 35= |           |        ~Cr y z t |           | Disable stack |
| {{{c15( RCL (i) )}}}   |     =45 24= |           |         ~C y z t |           |               |
| {{{c15( f Re≷Im )}}}   |     =42 30= |           |          C y z t |           | Ret           |
| {{{c15( g RTN   )}}}   |     =43 32= |           |                  |           |               |

* Newton's Method for Functions of a Complex Variable
:PROPERTIES:
:CUSTOM_ID: newton
:END:

Newton's method is an iterative root finding algorithm.  From an initial guess for a root, the method generates a sequence of guesses that, if we are
fortunate, converge to a root.

This program is a super simple implementation of Newton's method using only two registers and no internal labels.  Being minimal, this implementation doesn't
check for division by zero (small derivative) or zero progress (small delta x).  It will happily loop forever trying to converge -- i.e. it won't bail out
after an excessive number of iterations.

In what follows, the function we are solving is referred to as $f(x)$ and the initial guess is referred to as $x_0$.  The final guess is referred to as $x_n$.

If the calculator is not already in complex mode, then it will be placed in complex mode by the program.

** Usage

- Running the program
  - Stack Arguments:
    - {{{stk(T)}}} best guess for root ($x_0$)
    - {{{stk(Z)}}} best guess for root ($x_0$)
    - {{{stk(Y)}}} best guess for root ($x_0$)
    - {{{stk(X)}}} best guess for root ($x_0$)
  - Function to solve:
    - Must be {{{c15( LBL 1 )}}}
    - When called, $x$ will be on every level of the stack
    - Returns $f(x)$ to stack level {{{stk(X)}}} and $f'(x)$ to stack level {{{stk(Y)}}}.
      - Note this makes the program implementing $f(x)$ compatible with the built in {{{c15( SOLVE )}}} and {{{c15( ∫ )}}} functions.
  - At least one Newton iteration will always be executed allowing the program to refine a previously returned root one step at a time.
- Exit Information
  - Exit Stack State:
    - {{{stk(T)}}}: $f(x_n)$   Function value at $x_n$
    - {{{stk(Z)}}}: $|f(x_n)|$ Function magnitude at $x_n$ -- which will always be less than or equal to $\epsilon=10^{-7}$.
    - {{{stk(Y)}}}: $x_{n+1}$  The next iteration of Newton's method.  Normally a refined root; however, there is no guarantee.
    - {{{stk(X)}}}: $x_n$      Root guess
  - Exit Register State:
    - {{{reg( 8 )}}} $\Re(x_n)$
    - {{{reg( 9 )}}} $\Im(x_n)$
  - Non-normal Exits:
   - *Program might not converge:*  In this case it will run forever.  If the program is interrupted it is highly likely, but not guaranteed, the last guess will
     be stored in registers {{{reg( 8 )}}} & {{{reg( 9 )}}}.
   - *Evaluation error:* If the function causes an error during evaluation, the program will stop.  The last guess will be stored in {{{reg( 8 )}}} & {{{reg( 9 )}}}.
   - *Zero Derivative:* If the derivative is zero, then an "=Error 0=" will occur.   The last guess will be stored in {{{reg( 8 )}}} & {{{reg( 9 )}}}.

** Resources Used
:PROPERTIES:
:CUSTOM_ID: newtonRes
:END:

- Entry Point Label:
  - {{{lbl( C )}}} Program label
- Internal Labels:
  - None
- External Labels:
  - {{{lbl( 1 )}}} function to solve
  - {{{lbl( E )}}} =RCL_CPLX=
  - {{{lbl( D )}}} =STO_CPLX=
- Registers Used:
  - {{{reg( 8 )}}} Real component of root guess
  - {{{reg( 9 )}}} Complex component of root guess
- Matrices:
  - None

** Program Listing
:PROPERTIES:
:CUSTOM_ID: newtonCode
:END:

#+BEGIN_CENTER
=NEWTON= -- Newton's Method for a Function of a Complex Variable
#+END_CENTER
#+ATTR_HTML: :align center :cellpadding 1em
| <l>                    |         <r> |    <c>    |              <r> |    <c>    | <l>                |
| *Keystrokes* {{{SPC}}} | *Key Codes* | {{{SPC}}} | *Stack Contents* | {{{SPC}}} | *Comments*         |
| {{{c15( f LBL C  )}}}  |  =42,21,13= |           |         ? ? x0 ? |           |                    |
| {{{c15( R↓       )}}}  |        =33= |           |         ? x0 ? ? |           |                    |
| {{{c15( R↓       )}}}  |        =33= |           |         x0 ? ? ? |           |                    |
| {{{c15( 8        )}}}  |         =8= |           |         8 x0 ? ? |           |                    |
| {{{c15( GSB D    )}}}  |     =32 14= |           |         x0 ? ? 8 |           | STO_CPLX           |
| {{{c15( ENTER    )}}}  |        =36= |           |        x0 x0 ? ? |           | x0=Current iterate |
| {{{c15( ENTER    )}}}  |        =36= |           |       x0 x0 x0 ? |           |                    |
| {{{c15( ENTER    )}}}  |        =36= |           |      x0 x0 x0 x0 |           |                    |
| {{{c15( GSB 1    )}}}  |     =32  1= |           |         f df ? ? |           | f=f(x0), df=f'(x0) |
| {{{c15( ENTER    )}}}  |        =36= |           |         f f df ? |           |                    |
| {{{c15( ENTER    )}}}  |        =36= |           |         f f f df |           |                    |
| {{{c15( g R↑     )}}}  |     =43 33= |           |         df f f f |           |                    |
| {{{c15( ÷        )}}}  |        =10= |           |         dx f f f |           | dx=Delta x         |
| {{{c15( 8        )}}}  |         =8= |           |         8 dx f f |           |                    |
| {{{c15( GSB E    )}}}  |     =32 15= |           |          x0 dx f |           | RCL_CPLX           |
| {{{c15( -        )}}}  |        =30= |           |        -x1 f f f |           | x1=Next iterate    |
| {{{c15( CHS      )}}}  |        =16= |           |         x1 f f f |           |                    |
| {{{c15( g R↑     )}}}  |     =43 33= |           |         f x1 f f |           |                    |
| {{{c15( g ABS    )}}}  |     =43 16= |           |        fM x1 f f |           | fM=abs(f(x0))      |
| {{{c15( 7        )}}}  |         =7= |           |        7 fM x1 f |           |                    |
| {{{c15( CHS      )}}}  |        =16= |           |       -7 fM x1 f |           |                    |
| {{{c15( 10ˣ      )}}}  |        =13= |           |        e fM x1 f |           | e=Epsilon          |
| {{{c15( g TEST 8 )}}}  |  =43,30, 8= |           |        e fM x1 f |           | y>x?               |
| {{{c15( GTO C    )}}}  |     =22 .1= |           |        e fM x1 f |           |                    |
| {{{c15( R↓       )}}}  |        =33= |           |        fM x1 f e |           |                    |
| {{{c15( x≷y      )}}}  |        =34= |           |        x1 fM f e |           |                    |
| {{{c15( 8        )}}}  |         =8= |           |        8 x1 fM f |           |                    |
| {{{c15( GSB E    )}}}  |     =32 15= |           |       x0 x1 fM f |           | RCL_CPLX           |
| {{{c15( g RTN    )}}}  |     =43 32= |           |       x0 x1 fM f |           |                    |

* Matrix Helpers
:PROPERTIES:
:CUSTOM_ID: mat
:END:

These programs don't do anything the HP-15C can't already do.  They serve two purposes: 1) Reduce the number of keystrokes required, and 2) Free the user from
remembering the strange incantations required to work with complex matrices.

** Fill a Matrix
:PROPERTIES:
:CUSTOM_ID: matFill
:END:

*** Usage
:PROPERTIES:
:CUSTOM_ID: matFillUsage
:END:

This program, =STO_MAT=, provides a fast way to dimension & fill a real or complex matrix.  This program can Generally reduce keystroke overhead in half.

When flag {{{flg( 8 )}}} is clear, the real part of the value in the {{{stk(X)}}} stack level is placed in consecutive matrix elements.

When flag {{{flg( 8 )}}} is set, the program provides extra help in filling a *=C=* format complex matrix.  In this case, the real & complex parts of the
number in the {{{stk(X)}}} stack level are used to fill consecutive matrix elements.  If all the matrix elements are known in advance and in rectangular format, then
fewer keystrokes will be required with {{{flg( 8 )}}} clear:
#+ATTR_HTML: :align center
| flag {{{flg( 8 )}}} | Keystrokes per matrix element                                        |
|---------------------+----------------------------------------------------------------------|
| clear               | =real_part= {{{c15(R/S)}}} =imag_part= {{{c15(R/S)}}}                |
| set                 | =real_part= {{{c15(ENTER)}}} =imag_part= {{{c15(I)}}} {{{c15(R/S)}}} |
That said, setting flag {{{flg( 8 )}}} is *very* useful if some computation with the elements is required before we store them -- like converting them to
rectangular form with {{{c15(→R)}}}.  

- Operation
  - Run the program with the following inputs: 
    - {{{stk(Z)}}}: A matrix descriptor or number =0= (a =0= indicates the {{{c15(A)}}} matrix should be used)
    - {{{stk(Y)}}}: number of rows
    - {{{stk(X)}}}: Number of columns
  - The matrix element coordinate will appear on the display in =r.c= format.
  - The previously entered element, if there was one, will be on level {{{stk(Y)}}} of the stack.
  - Enter the value for the matrix position and press {{{c15(R/S)}}}.
    - If flag  {{{flg( 8 )}}}  is set, then the real and complex parts will be placed into the matrix in consecutive positions.
  - Repeat until all the matrix elements have been entered.
  - Note the program never ends -- it just wraps back to the start.

*** Resources Used
:PROPERTIES:
:CUSTOM_ID: matFillRes
:END:

- Entry Point Label:
  - {{{lbl( 7 )}}} =STO_MAT= -- =STO_MAT= on the left and =RCL_MAT= on the right -- just like the {{{c15(STO)}}} & {{{c15(RCL)}}} buttons.
- Internal Labels:
  - {{{lbl( .1 )}}} Main loop target
  - {{{lbl( .2 )}}} Complex if target
- External Labels:
  - None
- Flags:
  - {{{flg( 8 )}}} Option flag (complex mode)
  - {{{flg( 9 )}}} CF used as NOP
- Registers Used:
  - {{{reg( 0 )}}} Matrix indexing
  - {{{reg( 1 )}}} Matrix indexing
  - {{{reg( I )}}} Matrix descripter
- Matrices:
  - Matrix on stack level {{{stk(X)}}} when the program starts, or matrix A if {{{stk(X)}}} was zero.

*** Program Listing
:PROPERTIES:
:CUSTOM_ID: matFillCode
:END:

#+BEGIN_CENTER
=MAT_STO= -- Dimension & fill a Matrix
#+END_CENTER
#+ATTR_HTML: :align center :cellpadding 1em
| <l>                         |         <r> |    <c>    |              <r> |    <c>    | <l>                                   |
| *Keystrokes* {{{SPC}}}      | *Key Codes* | {{{SPC}}} | *Stack Contents* | {{{SPC}}} | *Comments*                            |
| {{{c15( f LBL 7        )}}} |  =42,21, 7= |           |     n m MATor0 t |           |                                       |
| {{{c15( RCL MATRIX A   )}}} |  =45,16,11= |           |     A n m MATor0 |           |                                       |
| {{{c15( STO I          )}}} |     =44 25= |           |     A n m MATor0 |           |                                       |
| {{{c15( g R↑           )}}} |     =43 33= |           |     MATor0 A n m |           |                                       |
| {{{c15( g TEST 0       )}}} |  =43,30, 0= |           |     MATor0 A n m |           |                                       |
| {{{c15( STO I          )}}} |     =44 25= |           |          A A n m |           | Sto given matrix descriptor in I      |
| {{{c15( R↓             )}}} |        =33= |           |     A n m MATor0 |           |                                       |
| {{{c15( R↓             )}}} |        =33= |           |     n m MATor0 A |           |                                       |
| {{{c15( f DIM I        )}}} |  =42,23,25= |           |     n m MATor0 A |           | Dim given matrix                      |
| {{{c15( f MATRIX 1     )}}} |  =42,16, 1= |           |     n m MATor0 A |           | Set R0 & R1 to 1                      |
| {{{c15( LBL .1         )}}} |  =42,21,.1= |           |      ?orXp ? ? ? |           | Ep -- previously entered element      |
| {{{c15( .              )}}} |        =48= |           |      - ?orXp ? ? |           |                                       |
| {{{c15( 1              )}}} |         =1= |           |      1 ?orXp ? ? |           |                                       |
| {{{c15( RCL × 1        )}}} |  =45,20, 1= |           |   j/10 ?orXp ? ? |           |                                       |
| {{{c15( RCL + 0        )}}} |  =45,40, 0= |           | j/10+i ?orXp ? ? |           |                                       |
| {{{c15( R/S            )}}} |        =31= |           |     j/10+i ? ? ? |           |                                       |
| {{{c15( f USER STO (i) )}}} | =u   44 24= |           |         Xr ? ? ? |           |                                       |
| {{{c15( f USER         )}}} |           - |           |         Xr ? ? ? |           | Exit USER mode                        |
| {{{c15( g CF 9         )}}} |  =43, 5, 9= |           |         Xr ? ? ? |           | NOP                                   |
| {{{c15( g F? 8         )}}} |  =43, 6, 8= |           |         Xr ? ? ? |           |                                       |
| {{{c15( GTO .2         )}}} |     =22 .2= |           |         Xr ? ? ? |           |                                       |
| {{{c15( GTO .1         )}}} |     =22 .1= |           |         Xr ? ? ? |           |                                       |
| {{{c15( f LBL .2       )}}} |  =42,21,.2= |           |         Xr ? ? ? |           |                                       |
| {{{c15( f Re≷Im        )}}} |     =42 30= |           |         Xc ? ? ? |           |                                       |
| {{{c15( f USER STO (i) )}}} | =u   44 24= |           |         Xc ? ? ? |           |                                       |
| {{{c15( f USER         )}}} |           - |           |         Xc ? ? ? |           | Exit USER mode                        |
| {{{c15( g CF 9         )}}} |  =43, 5, 9= |           |         Xc ? ? ? |           | NOP                                   |
| {{{c15( f Re≷Im        )}}} |     =42 30= |           |         Xr ? ? ? |           | So Xp will be in {{{stk(Y)}}} for R/S |
| {{{c15( GTO .1         )}}} |     =22 .1= |           |         Xr ? ? ? |           |                                       |
| {{{c15( g RTN          )}}} |     =43 32= |           |          ? ? ? ? |           | Never Get Here                        |

** Dump a Matrix
:PROPERTIES:
:CUSTOM_ID: matDump
:END:

*** Usage
:PROPERTIES:
:CUSTOM_ID: matDumpUsage
:END:

This program, =RCL_MAT=, provides a fast way iterate over the elements of a real or complex matrix.

 - Operation
  - Run the program with the following inputs: 
    - {{{stk(X)}}}: A matrix descriptor or number =0= (a =0= indicates the {{{c15(RESULT)}}} matrix should be used)
  - Each element of the matrix will be displayed.  Press {{{c15(R/S)}}} to advance.
     - The program will wrap around to the first element after the last one is displayed -- this is a feature.
     - If flag {{{flg( 8 )}}} is set, then *pairs* of elements are pulled from the matrix (i.e. *=C=* format) and placed on the stack as complex numbers

*** Resources Used
:PROPERTIES:
:CUSTOM_ID: matDumpRes
:END:

- Entry Point Label:
  - {{{lbl( 8 )}}} =RCL_MAT= -- =STO_MAT= on the left and =RCL_MAT= on the right -- just like the {{{c15(STO)}}} & {{{c15(RCL)}}} buttons.
- Internal Labels:
  - {{{lbl( .3 )}}} Main loop target
  - {{{lbl( .4 )}}} Complex if target
- External Labels:
  - None
- Flags:
  - {{{flg( 8 )}}} Option flag (complex mode)
  - {{{flg( 9 )}}} CF used as NOP
- Registers Used:
  - {{{reg( 0 )}}} Matrix indexing
  - {{{reg( 1 )}}} Matrix indexing
  - {{{reg( I )}}} Matrix descripter
- Matrices:
  - Matrix on stack level {{{stk(X)}}} when the program starts, or {{{c15(RESULT)}}} if {{{stk(X)}}} was zero.

*** Program Listing
:PROPERTIES:
:CUSTOM_ID: matDumpCode
:END:

#+BEGIN_CENTER
=MAT_RCL= -- Dump a Matrix
#+END_CENTER
#+ATTR_HTML: :align center :cellpadding 1em
| <l>                         |         <r> |    <c>    |               <r> |    <c>    | <l>              |
| *Keystrokes* {{{SPC}}}      | *Key Codes* | {{{SPC}}} |  *Stack Contents* | {{{SPC}}} | *Comments*       |
| {{{c15( f LBL 4        )}}} |  =42,21, 4= |           |      MATor0 y z t |           |                  |
| {{{c15( RCL RESULT     )}}} |     =45 26= |           | RESULT MATor0 y z |           |                  |
| {{{c15( STO I          )}}} |     =44 25= |           | RESULT MATor0 y z |           |                  |
| {{{c15( R↓             )}}} |        =33= |           | MATor0 y z RESULT |           |                  |
| {{{c15( g TEST 0       )}}} |  =43,30, 0= |           | MATor0 y z RESULT |           |                  |
| {{{c15( STO I          )}}} |     =44 25= |           | MATor0 y z RESULT |           |                  |
| {{{c15( f MATRIX 1     )}}} |  =42,16, 1= |           | MATor0 y z RESULT |           | Set R0 & R1 to 1 |
| {{{c15( LBL .3         )}}} |  =42,21,.3= |           |           ? ? ? ? |           |                  |
| {{{c15( f USER RCL (i) )}}} | =u   45 24= |           |      M(i)_r ? ? ? |           |                  |
| {{{c15( f USER         )}}} |           - |           |      M(i)_r ? ? ? |           | Exit USER mode   |
| {{{c15( g CF 9         )}}} |  =43, 5, 9= |           |      M(i)_r ? ? ? |           | NOP              |
| {{{c15( g F? 8         )}}} |  =43, 6, 8= |           |      M(i)_r ? ? ? |           |                  |
| {{{c15( GTO .4         )}}} |     =22 .4= |           |      M(i)_r ? ? ? |           |                  |
| {{{c15( R/S            )}}} |        =31= |           |      M(i)_r ? ? ? |           |                  |
| {{{c15( GTO .3         )}}} |     =22 .3= |           |      M(i)_r ? ? ? |           |                  |
| {{{c15( f LBL .4       )}}} |  =42,21,.4= |           |      M(i)_r ? ? ? |           |                  |
| {{{c15( f USER RCL (i) )}}} | =u   45 24= |           |      M(i)_c ? ? ? |           |                  |
| {{{c15( f USER         )}}} |           - |           |      M(i)_c ? ? ? |           | Exit USER mode   |
| {{{c15( g CF 9         )}}} |  =43, 5, 9= |           |      M(i)_c ? ? ? |           | NOP              |
| {{{c15( f I            )}}} |     =42 25= |           |      M(i)_r ? ? ? |           |                  |
| {{{c15( R/S            )}}} |        =31= |           |      M(i)_r ? ? ? |           |                  |
| {{{c15( GTO .3         )}}} |     =22 .3= |           |      M(i)_r ? ? ? |           |                  |
| {{{c15( g RTN          )}}} |     =43 32= |           |               N/A |           | Never Get Here   |

** Solve Linear System
:PROPERTIES:
:CUSTOM_ID: matSlv
:END:

*** Usage
:PROPERTIES:
:CUSTOM_ID: matSlvUsage
:END:

This program solves the system $AX=B$ for $X$.  

- Program start conditions
  - The $A$ matrix is stored in {{{mat(A)}}}.  
    - It may be an $n\times n$ real matrix, or an  $n\times 2n$ complex matrix in *=C=* format.
    - The program determines real vs. complex from the matrix size -- /not/ the setting of flag {{{flg(8)}}}.
  - The $B$ matrix is stored in {{{mat(B)}}}.  
  - Flag {{{flg( 1 )}}} is set appropriately:
    - Clear: Use more memory, but preserve contents of {{{mat(A)}}}.
    - Set: Use less memory, but destroy contents of {{{mat(A)}}}.
- Program end conditions
  - The system "solution", $X$, will be in {{{mat(C)}}}.  Note this might not be a valid solution if $A$ is singular!
  - {{{mat(B)}}} is left unchanged!
  - The matrix descriptor for {{{mat(C)}}} will be in stack position {{{stk(Y)}}}.
  - Matrix {{{mat(C)}}} will be selected as the {{{c15(RESULT)}}} matrix.
  - Both registers {{{reg(0)}}} & {{{reg(1)}}} will contain 1 in expectation {{{c15(USER)}}} mode will be used to visit the elements of {{{mat(C)}}}.
  - If $A$ is a real matrix:
    - Flag {{{flg( 0 )}}} will be clear
    - $\mathrm{det}(A)$ is in stack position X
    - The LU factorization of $A$ is in {{{mat(E)}}} when flag {{{flg( 1 )}}} is clear, and in {{{mat(A)}}} otherwise
  - If $A$ is a complex matrix
    - Flag {{{flg( 0 )}}} will be set
    - $\vert\mathrm{det}(A)\vert$ is in stack position {{{stk(X)}}}.
    - The LU factorization of $\tilde{A}$ is in {{{mat(E)}}} when flag {{{flg( 1 )}}} is clear, and in {{{mat(A)}}} otherwise

*** Resources Used
:PROPERTIES:
:CUSTOM_ID: matSlvRes
:END:

- Entry Point Label:
  - {{{lbl( 8 )}}} Program label
- Internal Labels:
  - None
- External Labels:
  - {{{lbl( 9 )}}} Subroutine to compute determinant
- Flags:
  - {{{flg( 0 )}}} Status flag
  - {{{flg( 1 )}}} Option flag
- Registers:
  - None
- Matrices:
  - {{{mat( A )}}}
  - {{{mat( B )}}}
  - {{{mat( C )}}} Used for the solution
  - {{{mat( E )}}} Only when flag 1 is clear

*** Program Listing
:PROPERTIES:
:CUSTOM_ID: matSlvCode
:END:

#+BEGIN_CENTER
=LIN_SLV= -- Solve $AX=B$
#+END_CENTER
#+ATTR_HTML: :align center :cellpadding 1em
| <l>                       |         <r> |    <c>    |                               <r> |    <c>    | <l>        |
| *Keystrokes* {{{SPC}}}    | *Key Codes* | {{{SPC}}} |                  *Stack Contents* | {{{SPC}}} | *Comments* |
| {{{c15( f LBL 8      )}}} |  =42,21, 8= |           |                           x y z t |           |            |
| {{{c15( GSB 9        )}}} |     =32  9= |           |         DET(A)orABS(DET(A)) ? ? ? |           |            |
| {{{c15( RCL MATRIX B )}}} |  =45,16,12= |           |     BorBc DET(A)orABS(DET(A)) ? ? |           |            |
| {{{c15( g F? 0       )}}} |  =43, 6, 0= |           |     BorBc DET(A)orABS(DET(A)) ? ? |           |            |
| {{{c15( f Py\,x      )}}} |     =42 40= |           |     BorBp DET(A)orABS(DET(A)) ? ? |           |            |
| {{{c15( RCL RESULT   )}}} |     =45 26= |           |   LU~ BorBp DET(A)orABS(DET(A)) ? |           |            |
| {{{c15( f RESULT C   )}}} |  =42,26,13= |           |   LU~ BorBp DET(A)orABS(DET(A)) ? |           |            |
| {{{c15( ÷            )}}} |        =10= |           |     CorCp DET(A)orABS(DET(A)) ? ? |           |            |
| {{{c15( g F? 0       )}}} |  =43, 6, 0= |           |     CorCp DET(A)orABS(DET(A)) ? ? |           |            |
| {{{c15( g Cy\,x      )}}} |     =43 40= |           |     CorCc DET(A)orABS(DET(A)) ? ? |           |            |
| {{{c15( x≷y          )}}} |        =34= |           |     DET(A)orABS(DET(A)) CorCc ? ? |           |            |
| {{{c15( f MATRIX 1   )}}} |  =42,16, 1= |           |     DET(A)orABS(DET(A)) CorCc ? ? |           |            |
| {{{c15( RCL MATRIX B )}}} |  =45,16,12= |           | BorBp DET(A)orABS(DET(A)) CorCc ? |           |            |
| {{{c15( g F? 0       )}}} |  =43, 6, 0= |           | BorBp DET(A)orABS(DET(A)) CorCc ? |           |            |
| {{{c15( g Cy\,x      )}}} |     =43 40= |           | BorBc DET(A)orABS(DET(A)) CorCc ? |           |            |
| {{{c15( R↓           )}}} |        =33= |           | DET(A)orABS(DET(A)) CorCc ? BorBc |           |            |
| {{{c15( g RTN        )}}} |     =43 32= |           | DET(A)orABS(DET(A)) CorCc ? BorBc |           |            |

** Matrix Determinants
:PROPERTIES:
:CUSTOM_ID: matDet
:END:

This program computes the determinant of a real matrix or the magnitude of the determinant for a complex matrix.  The use case is to determine if a matrix is
singular.

*** Usage
:PROPERTIES:
:CUSTOM_ID: matDetUsage
:END:

- Program start conditions
  - The $A$ matrix is assumed to be in {{{c15(A)}}}.  
    - It may be an $n\times n$ real matrix, or an  $n\times 2n$ complex matrix in *=C=* format.
    - The program determines real vs. complex from the matrix size.
  - flag {{{flg( 1 )}}} is set appropriately:
    - Clear: Use more memory, but preserve contents of {{{c15(A)}}}.
    - Set: Use less memory, but destroy contents of {{{c15(A)}}}.
- Program end conditions
  - The previous contents of the stack are lost
  - If flag {{{flg( 1 )}}} is clear
    - {{{c15(A)}}} is left unchanged!
    - {{{c15(RESULT)}}} matrix set as {{{c15(E)}}}
  - If flag {{{flg( 1 )}}} is set
    - {{{c15(RESULT)}}} matrix set as {{{c15(A)}}}
  - $A$ is a real matrix
    - Flag {{{flg( 0 )}}} will be clear
    - The $\mathrm{det}(A)$ is in stack position {{{stk(X)}}}.
    - The LU factorization of $A$ is in {{{c15(E)}}} when flag {{{flg( 1 )}}} is clear, and in {{{c15(A)}}} otherwise
  - If $A$ is a complex matrix
    - Flag {{{flg( 1 )}}} will be set
    - $\vert\mathrm{det}(A)\vert$ is in stack position {{{stk(X)}}}.
    - The LU factorization of $\tilde{A}$ is in {{{c15(E)}}} when flag {{{flg( 1 )}}} is clear, and in {{{c15(A)}}} otherwise

*** Resources Used
:PROPERTIES:
:CUSTOM_ID: matDetRes
:END:

- Entry Point Label:
  - {{{lbl( 9 )}}}  Program label
- Internal Labels:
  - None
  - {{{lbl( .9 )}}} Conditional label
- External Labels:
  - N/A
- Flags:
  - {{{flg( 0 )}}} exit flag
  - {{{flg( 1 )}}} option flag
- Registers:
  - N/A
- Matrices:
  - {{{mat( A )}}}
  - {{{mat( E )}}} Only when flag {{{flg( 1 )}}} is clear

*** Program Listing
:PROPERTIES:
:CUSTOM_ID: matDetCode
:END:

#+BEGIN_CENTER
=DET_A= -- Determinant of real A or magnitude of determinant of complex A
#+END_CENTER
#+ATTR_HTML: :align center :cellpadding 1em
| <l>                       |         <r> |    <c>    |                   <r> |    <c>    | <l>                            |
| *Keystrokes* {{{SPC}}}    | *Key Codes* | {{{SPC}}} |      *Stack Contents* | {{{SPC}}} | *Comments*                     |
| {{{c15( f LBL 9      )}}} |  =42,21, 9= |           |               x y z t |           |                                |
| {{{c15( f RESULT E   )}}} |  =42,26,15= |           |               x y z t |           |                                |
| {{{c15( g F? 1       )}}} |  =43, 6, 1= |           |               x y z t |           |                                |
| {{{c15( f RESULT A   )}}} |  =42,26,11= |           |               x y z t |           |                                |
| {{{c15( RCL DIM A    )}}} |  =45,23,11= |           |               n m x y |           |                                |
| {{{c15( g TEST 5     )}}} |  =43,30, 5= |           |               n m x y |           |                                |
| {{{c15( GTO .9       )}}} |     =22 .9= |           |               n m x y |           |                                |
| {{{c15( g SF 0       )}}} |  =43, 4, 0= |           |               n m x y |           |                                |
| {{{c15( RCL MATRIX A )}}} |  =45,16,11= |           |               A n m x |           |                                |
| {{{c15( f Py\,x      )}}} |     =42 40= |           |              Ap n m x |           |                                |
| {{{c15( f MATRIX 2   )}}} |  =42,16, 2= |           |              A~ n m x |           |                                |
| {{{c15( f MATRIX 9   )}}} |  =42,16, 9= |           | SQ(ABS(DET(A))) n m x |           |                                |
| {{{c15( g ABS        )}}} |     =43 16= |           | SQ(ABS(DET(A))) n m x |           | If roundoff made it negative   |
| {{{c15( √x           )}}} |        =11= |           |     ABS(DET(A)) n m x |           |                                |
| {{{c15( F? 1         )}}} |  =43, 6, 1= |           |     ABS(DET(A)) n m x |           |                                |
| {{{c15( g RTN        )}}} |     =43 32= |           |     ABS(DET(A)) n m x |           | Rtn when A cplx & flag 1 set   |
| {{{c15( RCL MATRIX A )}}} |  =45,16,11= |           |    A~ ABS(DET(A)) n m |           | Restore A to Ac form           |
| {{{c15( f MATRIX 3   )}}} |  =42,16, 3= |           |    Ap ABS(DET(A)) n m |           |                                |
| {{{c15( g Cy\,x      )}}} |     =43 40= |           |    Ac ABS(DET(A)) n m |           |                                |
| {{{c15( R↓           )}}} |        =33= |           |    ABS(DET(A)) x y Ac |           |                                |
| {{{c15( g RTN        )}}} |     =43 32= |           |    ABS(DET(A)) Cc x x |           | Rtn when A cplx & flag 1 clear |
| {{{c15( LBL .9       )}}} |  =42,21,.9= |           |               n m x y |           |                                |
| {{{c15( g CF 0       )}}} |  =43, 5, 0= |           |               n m x y |           |                                |
| {{{c15( RCL MATRIX A )}}} |  =45,16,11= |           |               A n m x |           |                                |
| {{{c15( f MATRIX 9   )}}} |  =42,16, 9= |           |          DET(A) n m x |           |                                |
| {{{c15( g RTN        )}}} |     =43 32= |           |          DET(A) n m x |           | Rtn when A real                |

* Quadratic Equation
:PROPERTIES:
:CUSTOM_ID: quadEqu
:END:

Find the two roots of \[ax^2+bx+c=0\] The coefficients may be real or complex.  Complex mode will automatically be enabled if required.  This program consumes
no storage registers or internal labels.  It requires 35 program lines consuming 36 bytes (if I counted correctly).

** Usage
:PROPERTIES:
:CUSTOM_ID: quadEquUsage
:END:

- Running the program
  - Stack Arguments:
    - {{{stk(Z)}}} $a$
    - {{{stk(Y)}}} $b$
    - {{{stk(X)}}} $c$
- Exit Information
  - Exit Stack State:
    - {{{stk(T)}}}: N/A
    - {{{stk(Z)}}}: N/A
    - {{{stk(Y)}}}: Second Root
    - {{{stk(X)}}}: First Root
  - Exit Flag State:
    - If the roots are complex, then {{{reg( 8 )}}} will be automatically set
  - Non-normal Exits:
   - If $\vert a\vert=0$, then the program will "=Error 0=".

** Resources Used
:PROPERTIES:
:CUSTOM_ID: quadEquRes
:END:

- Entry Point Labels:
  - {{{lbl( B )}}} SOLVE_QUAD
- Internal Labels:
  - None
- External Labels:
  - None
- Flags:
  - {{{flg( 8 )}}} Option flag (complex mode)
- Registers Used:
  - None
- Matrices:
  - None

** Program Listing
:PROPERTIES:
:CUSTOM_ID: quadEquCode
:END:

#+BEGIN_CENTER
=SOLVE_QUAD= -- Solve a quadratic equation
#+END_CENTER
#+ATTR_HTML: :align center :cellpadding 1em
| <l>                    |         <r> |    <c>    |                        <r> |    <c>    | <l>                 |
| *Keystrokes* {{{SPC}}} | *Key Codes* | {{{SPC}}} |           *Stack Contents* | {{{SPC}}} | *Comments*          |
| {{{c15( f LBL B  )}}}  |  =42,21,12= |           |                    c b a ? |           |                     |
| {{{c15( 0        )}}}  |         =0= |           |                    0 c b a |           |                     |
| {{{c15( +        )}}}  |        =40= |           |                    c b a a |           |                     |
| {{{c15( g R↑     )}}}  |     =43 33= |           |                    a c b a |           |                     |
| {{{c15( ÷        )}}}  |        =10= |           |                  c/a b a a |           |                     |
| {{{c15( x≷y      )}}}  |        =34= |           |                  b c/a a a |           |                     |
| {{{c15( g R↑     )}}}  |     =43 33= |           |                  a b c/a a |           |                     |
| {{{c15( ÷        )}}}  |        =10= |           |                b/a c/a a a |           |                     |
| {{{c15( x≷y      )}}}  |        =34= |           |                c/a b/a a a |           |                     |
| {{{c15( 4        )}}}  |         =4= |           |                4 c/a b/a a |           |                     |
| {{{c15( ×        )}}}  |        =20= |           |              4*c/a b/a a a |           |                     |
| {{{c15( x≷y      )}}}  |        =34= |           |              b/a 4*c/a a a |           |                     |
| {{{c15( ENTER    )}}}  |        =36= |           |            b/a b/a 4*c/a a |           |                     |
| {{{c15( CHS      )}}}  |        =16= |           |           -b/a b/a 4*c/a a |           |                     |
| {{{c15( 2        )}}}  |         =2= |           |           2 -b/a b/a 4*c/a |           |                     |
| {{{c15( ÷        )}}}  |        =10= |           |     -b/a/2 b/a 4*c/a 4*c/a |           |                     |
| {{{c15( R↓       )}}}  |        =33= |           |     b/a 4*c/a 4*c/a -b/a/2 |           |                     |
| {{{c15( g x²     )}}}  |     =43 11= |           | (b/a)^2 4*c/a 4*c/a -b/a/2 |           |                     |
| {{{c15( -        )}}}  |        =30= |           |     -D 4*c/a -b/a/2 -b/a/2 |           |                     |
| {{{c15( CHS      )}}}  |        =16= |           |      D 4*c/a -b/a/2 -b/a/2 |           |                     |
| {{{c15( g TEST 2 )}}}  |  =43,30, 2= |           |      D 4*c/a -b/a/2 -b/a/2 |           |                     |
| {{{c15( g SF 8   )}}}  |  =43, 4, 8= |           |      D 4*c/a -b/a/2 -b/a/2 |           | D<0 -> complex mode |
| {{{c15( √x       )}}}  |        =11= |           |     √D 4*c/a -b/a/2 -b/a/2 |           |                     |
| {{{c15( 2        )}}}  |         =2= |           |          2 √D 4*c/a -b/a/2 |           |                     |
| {{{c15( ÷        )}}}  |        =10= |           |   √D/2 4*c/a -b/a/2 -b/a/2 |           |                     |
| {{{c15( g R↑     )}}}  |     =43 33= |           |   -b/a/2 √D/2 4*c/a -b/a/2 |           |                     |
| {{{c15( x≷y      )}}}  |        =34= |           |   √D/2 -b/a/2 4*c/a -b/a/2 |           |                     |
| {{{c15( -        )}}}  |        =30= |           |            R1 4*c/a -b/a/2 |           |                     |
| {{{c15( g LSTx   )}}}  |     =43 36= |           |       √D/2 R1 4*c/a -b/a/2 |           |                     |
| {{{c15( g R↑     )}}}  |     =43 33= |           |       -b/a/2 √D/2 R1 4*c/a |           |                     |
| {{{c15( +        )}}}  |        =40= |           |          R2 R1 4*c/a 4*c/a |           |                     |
| {{{c15( g RTN    )}}}  |     =43 32= |           |          R2 R1 4*c/a 4*c/a |           |                     |

* Summary Resource Use
** Labels
:PROPERTIES:
:CUSTOM_ID: resSumLab
:END:

My general strategy for using labels is as follows:

#+ATTR_HTML: :border 2 solid #ccc :frame hsides :align center
|                <c>                | <l>                        |
|             Registers             | Use In Programs            |
|-----------------------------------+----------------------------|
| {{{lbl(  A )}}} - {{{lbl(  E )}}} | Frequently called programs |
|          {{{lbl( 0 )}}}           | Unused                     |
| {{{lbl(  1 )}}} - {{{lbl(  3 )}}} | Solver/Integrator programs |
| {{{lbl(  4 )}}} - {{{lbl(  5 )}}} | Unused                     |
| {{{lbl(  6 )}}} - {{{lbl(  9 )}}} | Matrix stuff               |
|          {{{lbl( .0 )}}}          | Unused                     |
| {{{lbl( .1 )}}} - {{{lbl( .9 )}}} | Internal lables            |

*** Label Assignments
:PROPERTIES:
:CUSTOM_ID: resSumLabAss
:END:

#+ATTR_HTML: :border 2 solid #ccc :frame hsides :align center
|       <c>       | <l>                                    |            <r> |
| {{{lbl(LBL)}}}  | Use                                    |        Used By |
|-----------------+----------------------------------------+----------------|
| {{{lbl( A )}}}  | -                                      |                |
| {{{lbl( B )}}}  | [[#quadEqu][Solve Quadratic]]          |                |
| {{{lbl( C )}}}  | [[#newton][Complex Newton's Method]]   |                |
| {{{lbl( D )}}}  | [[#storclcplx][Store Complex Number]]  | {{{lbl( C )}}} |
| {{{lbl( E )}}}  | [[#storclcplx][Recall Complex Number]] | {{{lbl( C )}}} |
|-----------------+----------------------------------------+----------------|
| {{{lbl( 0 )}}}  | -                                      |                |
| {{{lbl( 1 )}}}  | Solver/Integrator/[[#newton][Newton]]  | {{{lbl( C )}}} |
| {{{lbl( 2 )}}}  | Solver/Integrator                      |                |
| {{{lbl( 3 )}}}  | Solver/Integrator                      |                |
| {{{lbl( 4 )}}}  | -                                      |                |
| {{{lbl( 5 )}}}  | -                                      |                |
| {{{lbl( 6 )}}}  | [[#matSlv][Solve Linear System]]       |                |
| {{{lbl( 7 )}}}  | [[#matFill][Fill A Matrix]]            |                |
| {{{lbl( 8 )}}}  | [[#matDump][Dump A Matrix]]            |                |
| {{{lbl( 9 )}}}  | [[#matDet][Determinant]]               | {{{lbl( 6 )}}} |
|-----------------+----------------------------------------+----------------|
| {{{lbl( .0 )}}} | -                                      |                |
| {{{lbl( .1 )}}} | Internal                               |   {{{lbl(7)}}} |
| {{{lbl( .2 )}}} | Internal                               |   {{{lbl(7)}}} |
| {{{lbl( .3 )}}} | Internal                               |   {{{lbl(8)}}} |
| {{{lbl( .4 )}}} | Internal                               |   {{{lbl(8)}}} |
| {{{lbl( .5 )}}} | -                                      |                |
| {{{lbl( .6 )}}} | -                                      |                |
| {{{lbl( .7 )}}} | -                                      |                |
| {{{lbl( .8 )}}} | -                                      |                |
| {{{lbl( .9 )}}} | -                                      |                |

** Registers
:PROPERTIES:
:CUSTOM_ID: resSumReg
:END:

How I normally use register storage.  

#+ATTR_HTML: :border 2 solid #ccc :frame hsides :align center
|                <c>                | <l>                            | <l>                                     |
|             Registers             | Use In Programs                | Interactive Use                         |
|-----------------------------------+--------------------------------+-----------------------------------------|
| {{{reg(  0 )}}} - {{{reg(  1 )}}} | Always for matrix indexes$^1$  | Whatever, but usually as matrix indexes |
| {{{reg(  2 )}}} - {{{reg(  7 )}}} | Always for statistics$^1$      | Whatever, but usually for statistics    |
| {{{reg(  8 )}}} - {{{reg(  9 )}}} | User visible program registers | Whatever, but usually for programs      |
| {{{reg( .0 )}}} - {{{reg( .6 )}}} | Whatever                       | Whatever                                |
| {{{reg( .7 )}}} - {{{reg( .9 )}}} | Unit conversion factors$^2$    | Unit conversion factors                 |

 1) I avoid using the matrix & staticial registers in programs because I ocassionally use matrix & statstical functions in solver programs.  For example, if I
    had used these registers in the [[#newton][Complex Newton's Method]] program then I wouldn't be able to do that.
 2) Conversions: in to cm, lb to kg, US gal to liters.  Keys =7= to =9= mirror unit conversion keys on another calculator. =;)=

** Matrix Registers
:PROPERTIES:
:CUSTOM_ID: resSumMat
:END:

How I normally use matrix storage.  These habits have strongly influenced the matrix helper routines.  

#+ATTR_HTML: :border 2 solid #ccc :frame hsides :align center
|        <c>        | <l>                                                                               |
| {{{c15(MATRIX)}}} | Use                                                                               |
|-------------------+-----------------------------------------------------------------------------------|
|  {{{mat( A )}}}   | Determinants & LHS of matrix equations ($AX=B$)                                   |
|  {{{mat( B )}}}   | RHS of matrix equations ($AX=B$)                                                  |
|  {{{mat( C )}}}   | Solution for $AX=B$                                                               |
|  {{{mat( D )}}}   | Unused                                                                            |
|  {{{mat( E )}}}   | $LU$ of $A$ for determinants & matrix equations when flag {{{flg( 1 )}}} is clear |

** Flags
:PROPERTIES:
:CUSTOM_ID: resSumFlags
:END:

#+ATTR_HTML: :border 2 solid #ccc :frame hsides :align center
|             <c>             | <l>                                |
|            Flag             | Use                                |
|-----------------------------+------------------------------------|
|        {{{flg(0)}}}         | Inter program status messages      |
|        {{{flg(1)}}}         | Externally visable program options |
| {{{flg(2)}}} - {{{flg(7)}}} | Unused                             |
|        {{{flg(8)}}}         | System flag: complex mode          |
|        {{{flg(9)}}}         | System flag: overflow              |

** Program Steps
:PROPERTIES:
:CUSTOM_ID: resSumSteps
:END:

I normally keep =STO_CPLX=, =RCL_CPLX=, =NEWTON=, =STO_MAT=, =RCL_MAT=, =LIN_SLV=, and =DET_A= in program memory.  This results in 143 lines of program memory
consumed by the programs.  I then add three zeros at the end as a little pad to separate my permanent programs from whatever I may add to the end of program
memory.

#+ATTR_HTML: :border 2 solid #ccc :frame hsides :align center
| <c>  |        <r> | <l>                  | <l>                                    |
| Step |  Key Codes | Keystrokes           | Use                                    |
|------+------------+----------------------+----------------------------------------|
| 001  | =42 21 14= | {{{c15( f LBL D )}}} | [[#storclcplx][Store Complex Number]]  |
| 011  | =42 21 15= | {{{c15( f LBL E )}}} | [[#storclcplx][Recall Complex Number]] |
| 022  | =42 21 13= | {{{c15( f LBL C )}}} | [[#newton][Complex Newton's Method]]   |
| 051  | =42 21  7= | {{{c15( f LBL 7 )}}} | [[#matFill][Fill A Matrix]]            |
| 079  | =42 21  8= | {{{c15( f LBL 8 )}}} | [[#matDump][Dump A Matrix]]            |
| 100  | =42 21  6= | {{{c15( f LBL 6 )}}} | [[#matSlv][Solve Linear System]]       |
| 117  | =42 21  9= | {{{c15( f LBL 9 )}}} | [[#matDet][Determinant]]               |
| 143  |        =0= | {{{c15( 0 )}}}       | Padding                                |
| 144  |        =0= | {{{c15( 0 )}}}       | Padding                                |
| 145  |        =0= | {{{c15( 0 )}}}       | Padding                                |
| 146  |        N/A | N/A                  | Solver programs etc...                 |

* Downloads
:PROPERTIES:
:CUSTOM_ID: downloads
:END:

I regularly use [[https://hp-15c-simulator.de/][Torsten Manz's excellent HP-15C simulator]] on Windows & Linux.  It can load and save programs written in a
simple Unicode file format and it can also create "memory image" files that may be loaded on the HP-15CE, DM15C, & DM15L calculators!  I can't recommend it
highly enough.

On Android I use [[https://jrpn.jovial.com/][Bill Foote's JRPN HP-15 simulator]] which is capable of using the source program files Manz's simulator writes so
I can keep my programs synced between my phone, tablet, and laptop!

- My normal program load as [[#resSumSteps][described above]]:
  - [[https://github.com/richmit/voyager/blob/main/downloads/hp15c-MJR_programs-text.15c][Source code]]
  - [[https://github.com/richmit/voyager/blob/main/downloads/hp15c-MJR_programs-ram.15CE][192 register RAM image for the HP-15CE]]
- [[https://github.com/richmit/voyager/blob/main/downloads/hp15c-SOLVE_QUAD-text.15c][=SOLVE_QUAD= source code]]

* Meta Data
:PROPERTIES:
:CUSTOM_ID: meta
:END:

The primary URL for this page: https://richmit.github.io/voyager/hp15.html

The org mode file for this page: https://github.com/richmit/voyager/blob/main/docs/hp15.org

The HTML file for this page: https://github.com/richmit/voyager/blob/main/docs/hp15.html

The github repository housing this content: https://github.com/richmit/voyager/
